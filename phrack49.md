Bài viết được dịch từ http://phrack.org/issues/49/14.html#article
###I. Cấu trúc bộ nhớ 
  Để hiểu những gì bộ đệm của stack đầu tiên chúng ta phải hiểu quá trinh này được tổ chức như thế nào trong bộ nhớ. Quá trình được chia làm 3 phần. Text, Data và Stack. Chúng ta sẽ tập trung về phần Stack, nhưng trước tiên cần có một cái nhìn tổng quan về các khu vực nhỏ khác theo thứ tự.
  
  Các khu vực văn bản được cố định bởi chương trình và bao gồm cả code, chỉ đọc dữ liệu. Khu vực này tương ứng với phần văn bản của các tệp tin được thực thi. Khu vực này được đánh dấu chỉ đọc và bất kỳ sự xâm phạm để ghi nó sẽ dẫn đến kết quả trong một segmentation violation.

  Khu vực chứa data được khởi tạo và chưa được khởi tạo. Các biến tĩnh được lưu trữ ở khu vực này. Vùng data tương ứng với phần data-bss của file thực thi. Kích thước của nó có thể thay đổi khi hệ thống gọi brk(2). Nếu việc mở rộng data-bss hoặc người sử dụng hết stack bộ nhớ có sẵn, quá trình này sẽ bị chặn và được dời lại để chạy với không gian bộ nhớ lớn hơn. Bộ nhớ mới sẽ được thêm vào giữa data và stack segments.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

Stack là gì ?

Một stack là một kiểu dữ liệu trừu tượng thường được sử dụng trong khoa học máy tính. Một stack của đối tượng có đặc tính mà các đối tượng cuối cùng đặt lên trên stack sẽ là đối tượng đầu tiên được lấy ra, loại bỏ. Đặc tính được gọi chung là vào sau ra trước hoặc LIFO.

Một số hoạt động được xác định trên stack và 2 cái quan trọng nhất là push và pop. PUSH là thêm một phần tử vào đỉnh stack.  POP thì ngược lại, giảm kích thước của stack bằng một cách loại bỏ một phần tử cuối cùng tại đỉnh stack.

Tại sao chúng ta sử dụng stack ?

Các stack cũng được sử dụng tự động phân phát các biến cục bộ sử dụng trong funcitons, để truyền tham số funciton và trả về một giá trị của funciton.
 
Vùng Stack

Một stack là một khối liền kề của bộ nhớ chứa dữ liệu. Một thanh ghi được gọi khi con trỏ ngăn xếp (SP) trỏ đến đỉnh stack. Phần dưới cùng của stack sẽ là một địa chỉ được cố định. Kích thước của nó tự động điểu chỉnh bởi kernel trong lúc chạy. CPU thực hiện các hướng dẫn để PUSH và POP lên stack. Các stack gồm các stack frames luận lí để PUSH khi gọi một function và POP khi trả về, bao gồm giá trị của con trỏ tại thời điểm khi function được gọi.

Tùy thuộc vào các việc thực hiện mà stack sẽ xuống ( về phía các địa chỉ bộ nhớ thấp hơn) hoặc tăng.  Trong ví dụ dưới đây, chúng tôi sẽ sử dụng stack để giảm xuống địa chỉ bộ nhớ thấp hơn. Đây là cách ngăn xếp phát triển trên nhiều máy tính bao gồm Intel, bộ vi xử lý Motorola, SPARC và MIPS. Con trỏ stack (SP) cũng phụ thuộc vào việc thực hiện. Nó có thể đến vị trí cuối cùng của stack hoặc đến địa chỉ có sẵn không sử dụng tiếp theo. Để thảo luận, chúng tôi sẽ chiếm lấy con trỏ đến địa chỉ cuối của stack.

Ngoài các con trỏ stack mà điểm đến của nó là đỉnh stack ( địa chỉ thấp nhất), nó cũng thích hợp cho việc frame pointer  (FP)  chỉ vào một vị trí cố định trong frame. Một số text cũng được xem như một local base pointer (LB).  Về nguyên tắc, các biến cục bộ cũng có thể tham chiếu bằng cách địa chỉ offset từ SP. Tuy nhiên, PUSH lên đỉnh stack và POP từ stack thì offset cũng thay đổi. Mặc dù trong một số trường hợp trình biên dịch có thể theo dõi số lượng từ stack, từ đó điểu chính các offset, trong một vài trường hợp có thể không và trong mọi trường hợp administration là cần thiết. Hơn nữa trên một số máy, chẳng hạn như bộ xử lí Intel, truy cập một biến cách xa từ SP đòi hỏi phải có nhiều hướng dẫn. 

Do đó, nhiều trình biên dịch sử dụng một thanh ghi thứ hai, FP, để tham chiếu đến các biến cục bộ và các tham số bởi vì cách biệt ra từ FP không làm thay đổi PUSH và POP.
Trên các CPU Intel, BP (EBP) được sử dụng cho mục đích này. Trên các CPU Motorola, sẽ làm bất kì thanh ghi nào ngoại trừ A7 ( con trỏ stack) . Bởi vì cách mà chúng tôi phát triển stack 
            
			


