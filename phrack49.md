Bài viết được dịch từ http://phrack.org/issues/49/14.html#article
###I. Cấu trúc bộ nhớ 
  Để hiểu những gì bộ đệm của stack đầu tiên chúng ta phải hiểu quá trinh này được tổ chức như thế nào trong bộ nhớ. Quá trình được chia làm 3 phần. Text, Data và Stack. Chúng ta sẽ tập trung về phần Stack, nhưng trước tiên cần có một cái nhìn tổng quan về các khu vực nhỏ khác theo thứ tự.
  
  Các khu vực văn bản được cố định bởi chương trình và bao gồm cả code, chỉ đọc dữ liệu. Khu vực này tương ứng với phần văn bản của các tệp tin được thực thi. Khu vực này được đánh dấu chỉ đọc và bất kỳ sự xâm phạm để ghi nó sẽ dẫn đến kết quả trong một segmentation violation.

  Khu vực chứa data được khởi tạo và chưa được khởi tạo. Các biến tĩnh được lưu trữ ở khu vực này. Vùng data tương ứng với phần data-bss của file thực thi. Kích thước của nó có thể thay đổi khi hệ thống gọi brk(2). Nếu việc mở rộng data-bss hoặc người sử dụng hết stack bộ nhớ có sẵn, quá trình này sẽ bị chặn và được dời lại để chạy với không gian bộ nhớ lớn hơn. Bộ nhớ mới sẽ được thêm vào giữa data và stack segments.

 			     /------------------\  lower
                             |                  |  memory
                             |       Text       |  addresses
                             |                  |
                             |------------------|
                             |   (Initialized)  |
                             |        Data      |
                             |  (Uninitialized) |
                             |------------------|
                             |                  |
                             |       Stack      |  higher
                             |                  |  memory
                             \------------------/  addresses

                         Fig. 1 Process Memory Regions

				Stack là gì ?

Một stack là một kiểu dữ liệu trừu tượng thường được sử dụng trong khoa học máy tính. Một stack của đối tượng có đặc tính mà các đối tượng cuối cùng đặt lên trên stack sẽ là đối tượng đầu tiên được lấy ra, loại bỏ. Đặc tính được gọi chung là vào sau ra trước hoặc LIFO.

Một số hoạt động được xác định trên stack và 2 cái quan trọng nhất là push và pop. PUSH là thêm một phần tử vào đỉnh stack.  POP thì ngược lại, giảm kích thước của stack bằng một cách loại bỏ một phần tử cuối cùng tại đỉnh stack.

				Tại sao chúng ta sử dụng stack ?

Các stack cũng được sử dụng tự động phân phát các biến cục bộ sử dụng trong funcitons, để truyền tham số funciton và trả về một giá trị của funciton.
 
				Vùng Stack

Một stack là một khối liền kề của bộ nhớ chứa dữ liệu. Một thanh ghi được gọi khi con trỏ ngăn xếp (SP) trỏ đến đỉnh stack. Phần dưới cùng của stack sẽ là một địa chỉ được cố định. Kích thước của nó tự động điểu chỉnh bởi kernel trong lúc chạy. CPU thực hiện các hướng dẫn để PUSH và POP lên stack. Các stack gồm các stack frames luận lí để PUSH khi gọi một function và POP khi trả về, bao gồm giá trị của con trỏ tại thời điểm khi function được gọi.

Tùy thuộc vào các việc thực hiện mà stack sẽ xuống ( về phía các địa chỉ bộ nhớ thấp hơn) hoặc tăng.  Trong ví dụ dưới đây, chúng tôi sẽ sử dụng stack để giảm xuống địa chỉ bộ nhớ thấp hơn. Đây là cách ngăn xếp phát triển trên nhiều máy tính bao gồm Intel, bộ vi xử lý Motorola, SPARC và MIPS. Con trỏ stack (SP) cũng phụ thuộc vào việc thực hiện. Nó có thể đến vị trí cuối cùng của stack hoặc đến địa chỉ có sẵn không sử dụng tiếp theo. Để thảo luận, chúng tôi sẽ chiếm lấy con trỏ đến địa chỉ cuối của stack.

Ngoài các con trỏ stack mà điểm đến của nó là đỉnh stack ( địa chỉ thấp nhất), nó cũng thích hợp cho việc frame pointer  (FP)  chỉ vào một vị trí cố định trong frame. Một số text cũng được xem như một local base pointer (LB).  Về nguyên tắc, các biến cục bộ cũng có thể tham chiếu bằng cách địa chỉ offset từ SP. Tuy nhiên, PUSH lên đỉnh stack và POP từ stack thì offset cũng thay đổi. Mặc dù trong một số trường hợp trình biên dịch có thể theo dõi số lượng từ stack, từ đó điểu chính các offset, trong một vài trường hợp có thể không và trong mọi trường hợp administration là cần thiết. Hơn nữa trên một số máy, chẳng hạn như bộ xử lí Intel, truy cập một biến cách xa từ SP đòi hỏi phải có nhiều hướng dẫn. 

Do đó, nhiều trình biên dịch sử dụng một thanh ghi thứ hai, FP, để tham chiếu đến các biến cục bộ và các tham số bởi vì cách biệt ra từ FP không làm thay đổi PUSH và POP. Trên các CPU Intel, BP (EBP) được sử dụng cho mục đích này. Trên các CPU Motorola, sẽ làm bất kì thanh ghi nào ngoại trừ A7 ( con trỏ stack) . Bởi vì cách mà chúng tôi phát triển stack, các tham số offset lớn hơn số không và biến cục bộ không nhận offset từ FP.

Điều đầu tiên của một thủ tục phải làm khi được gọi là lưu ở FP trước (do đó, nó có thể được phục hồi ở phần thoát của thủ tục). Sau đó nó sao chép SP vào FP để tạo FP mới và sự tăng lên của SP từ không gian lưu trữ cho các biến cục bộ. Những code này được là các thủ tục prolog. Khi các thủ tục thoát, stack sẽ được làm trống một lần nữa.

Chúng ta hãy xem những gì diễn ra ở stack ở một ví dụ đơn giản:

 example1.c :
---------------------------------------------------------------------------------------------------------
void function(int a, int b, int c) {
   char buffer1[5];
   char buffer2[10];
}

void main() {
  function(1,2,3);
}
----------------------------------------------------------------
Để hiểu được chương trình sẽ làm gì khi gọi function, chúng ta sẽ biên dịch nó với gcc sử dụng lựa chọn –S để tạo ra code assembly:

$ gcc -S -o example1.s example1.c

Bằng cách nhìn và ngôn ngữ assembly chúng ta sẽ thấy chương trình khi gọi một hàm sẽ được dịch ra như dưới đây: 
        pushl $3
        pushl $2
        pushl $1
        call function

Đoạn ở trên này sẽ đẩy 3 tham số của một function từ phải qua trái vào stack và gọi function(). Các hướng dẫn call sẽ đẩy con trỏ IP và stack. Chúng tôi sẽ gọi IP là nơi lưu trữ địa chỉ được trả về (RET). Đây sẽ là điều đầu tiên được thực hiện thủ tục prolog trong một function: 

       pushl %ebp
       movl %esp,%ebp
       subl $20,%esp

Điều này sẽ đẩy EBP (frame pointer) và đỉnh stack. Nó sao chép EBP vào SP, tạo ra một FP mới. Chúng tôi sẽ gọi FP là nơi lưu trữ con trỏ SFP (con trỏ chứa địa chỉ bắt đầu của stack). Sau đó nó sẽ phân chia không gian cho các biến cục bộ bằng cách trừ đi kích thước của ESP. Chúng ta phải nhớ, bộ nhớ chỉ có thể được giải quyết trong nhiều phần của kích thước word. Một word trong trường hợp của chúng ta sẽ chiếm 4 bytes hoặc 32bit, 1 byte = 8 bit. Vì vậy, 5 bytes của bộ đệm thực sự sẽ mất 8 bytes ( 2 words) của bộ nhớ và 10 bytes của bộ đệm sẽ mất 12 bytes ( 3 words) của bộ nhớ. Đó là lí do tại sao SP lại trừ đi 20. Với những điều này, stack sẽ như thế này khi function được gọi ( mỗi không gian lưu trữ đại diện cho 1 byte):

bottom of                                                            top of
memory                                                               memory
               buffer2     buffer1     sfp    ret       a      b     c
<------   [            ][                ][      ][       ][       ][      ][     ]
	   
top of                                                            	bottom of
stack                                                                        stack
 








			


			


